{"version":3,"sources":["../src/index.js"],"names":["context","config","defaultConfig","Object","assign","errorRegExps","ignoredMessages","map","RegExp","message","filterOutError","match","text","matchedText","ruleIssueType","dictionary","indexOf","i","length","test","addErrors","res","node","hasOwnProperty","matches","matchVal","substr","offset","trim","Math","min","report","RuleError","promiseQueue","Syntax","Document","documentCounter","increase","currentCount","current","Promise","all","then","isLast","lt","kill","Str","getSource","push","check","language","split","part","filter","forEach","require","DocumentCounter","counter","number"],"mappings":"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","file":"index.js","sourcesContent":["\"use strict\";\n\nlet defaultConfig = {\n    language: 'en-US',\n    ignoredMessages: [],\n    dictionary: [],\n};\n\nlet lt = require('node-languagetool');\n\nclass DocumentCounter {\n    constructor() {\n        this.counter = 0;\n    }\n\n    increase() {\n        this.counter++;\n    }\n\n    current() {\n        return this.counter;\n    }\n\n    isLast(number) {\n        return number === this.counter;\n    }\n}\n\nconst documentCounter = new DocumentCounter();\n\n/**\n * @param {RuleContext} context\n * @param {object} config\n */\nexport default function (context, config = defaultConfig) {\n    if (typeof(config) === 'boolean') {\n        if (! config) {\n            return;\n        }\n        config = defaultConfig;\n    } else {\n        config = Object.assign({}, defaultConfig, config);\n    }\n\n    const errorRegExps = config.ignoredMessages.map(message => new RegExp(message));\n\n    let filterOutError = function (match, text, matchedText) {\n        if (match.ruleIssueType === 'misspelling' && config.dictionary.indexOf(matchedText) > -1) {\n            return true;\n        }\n        for (let i = 0; i < errorRegExps.length; ++i) {\n            if (errorRegExps[i].test(match.message)) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    let addErrors = function (res, text, node) {\n        if (! res || ! res.hasOwnProperty('matches')) {\n            return;\n        }\n        for (let match in res.matches) {\n            if (! res.matches.hasOwnProperty(match)) {\n                continue;\n            }\n            let matchVal = res.matches[match];\n            let matchedText = text.substr(matchVal.offset, matchVal.length);\n            if (matchedText.trim().length === 0) {\n                matchedText = text.substr(Math.min(matchVal.offset - 8, 0), matchVal.length + 16);\n            }\n            if (filterOutError(matchVal, text, matchedText)) {\n                continue;\n            }\n            context.report(node, new context.RuleError(matchVal.message + (matchedText ? ': ' + matchedText : '')));\n        }\n    };\n\n    const promiseQueue = [];\n\n    // rule object\n    return {\n        [context.Syntax.Document]() {\n            documentCounter.increase();\n        },\n        [`${context.Syntax.Document}:exit`]() {\n            if (promiseQueue.length === 0) {\n                return;\n            }\n            let currentCount = documentCounter.current();\n            return Promise.all(promiseQueue).then(() => {\n                if (documentCounter.isLast(currentCount)) {\n                    lt.kill();\n                }\n            });\n        },\n        [context.Syntax.Str](node) {\n            const text = context.getSource(node).trim();\n            if (text.trim().length === 0) {\n                return;\n            }\n\n            if (! text.match(/\\s+|\\s+(.*)/)) {\n                promiseQueue.push(lt.check(text, config.language).then(res => addErrors(res, text, node)))\n                return;\n            }\n\n            text.split('|').map(part => part.trim()).filter(part => part.length > 0).forEach(part => {\n                promiseQueue.push(lt.check(part, config.language).then(res => addErrors(res, part, node)));\n            });\n        }\n    };\n}\n"]}