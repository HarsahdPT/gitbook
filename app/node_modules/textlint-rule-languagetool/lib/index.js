"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = function (context) {
    var _ref;

    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultConfig;

    if (typeof config === 'boolean') {
        if (!config) {
            return;
        }
        config = defaultConfig;
    } else {
        config = Object.assign({}, defaultConfig, config);
    }

    var errorRegExps = config.ignoredMessages.map(function (message) {
        return new RegExp(message);
    });

    var filterOutError = function filterOutError(match, text, matchedText) {
        if (match.ruleIssueType === 'misspelling' && config.dictionary.indexOf(matchedText) > -1) {
            return true;
        }
        for (var i = 0; i < errorRegExps.length; ++i) {
            if (errorRegExps[i].test(match.message)) {
                return true;
            }
        }
        return false;
    };

    var addErrors = function addErrors(res, text, node) {
        if (!res || !res.hasOwnProperty('matches')) {
            return;
        }
        for (var match in res.matches) {
            if (!res.matches.hasOwnProperty(match)) {
                continue;
            }
            var matchVal = res.matches[match];
            var matchedText = text.substr(matchVal.offset, matchVal.length);
            if (matchedText.trim().length === 0) {
                matchedText = text.substr(Math.min(matchVal.offset - 8, 0), matchVal.length + 16);
            }
            if (filterOutError(matchVal, text, matchedText)) {
                continue;
            }
            context.report(node, new context.RuleError(matchVal.message + (matchedText ? ': ' + matchedText : '')));
        }
    };

    var promiseQueue = [];

    // rule object
    return _ref = {}, _defineProperty(_ref, context.Syntax.Document, function () {
        documentCounter.increase();
    }), _defineProperty(_ref, context.Syntax.Document + ':exit', function undefined() {
        if (promiseQueue.length === 0) {
            return;
        }
        var currentCount = documentCounter.current();
        return Promise.all(promiseQueue).then(function () {
            if (documentCounter.isLast(currentCount)) {
                lt.kill();
            }
        });
    }), _defineProperty(_ref, context.Syntax.Str, function (node) {
        var text = context.getSource(node).trim();
        if (text.trim().length === 0) {
            return;
        }

        if (!text.match(/\s+|\s+(.*)/)) {
            promiseQueue.push(lt.check(text, config.language).then(function (res) {
                return addErrors(res, text, node);
            }));
            return;
        }

        text.split('|').map(function (part) {
            return part.trim();
        }).filter(function (part) {
            return part.length > 0;
        }).forEach(function (part) {
            promiseQueue.push(lt.check(part, config.language).then(function (res) {
                return addErrors(res, part, node);
            }));
        });
    }), _ref;
};

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultConfig = {
    language: 'en-US',
    ignoredMessages: [],
    dictionary: []
};

var lt = require('node-languagetool');

var DocumentCounter = function () {
    function DocumentCounter() {
        _classCallCheck(this, DocumentCounter);

        this.counter = 0;
    }

    _createClass(DocumentCounter, [{
        key: 'increase',
        value: function increase() {
            this.counter++;
        }
    }, {
        key: 'current',
        value: function current() {
            return this.counter;
        }
    }, {
        key: 'isLast',
        value: function isLast(number) {
            return number === this.counter;
        }
    }]);

    return DocumentCounter;
}();

var documentCounter = new DocumentCounter();

/**
 * @param {RuleContext} context
 * @param {object} config
 */
//# sourceMappingURL=index.js.map